# sync.WaitGroup 作用
1. 等待一组协程完成
2. 工作原理：通过计数器来获取协程的完成情况
3. 启动一个协程计数器 + 1， 协程退出计数器 -1
4. 通过wait方式阻塞主进程，等待计数器清零后才能继续执行后续操作

# sync.WaitGroup 应用场景
1. 通过协程并行执行一组任务，且任务全部完成后才能进行下一步操作的情况
2. 例如：汽车的生成，所有零件可以并行生产，只能等到所有零件生成完成后，才能组装

# syn.WaitGroup 陷阱
1. 协程间传递时需要以指针的方式或闭包的方式引入 WaitGroup 对象，否则会造成死锁

# sync.Cond 作用
1. 设置一组协程根据条件阻塞，可以根据不同的条件阻塞
2. 可以根据条件唤醒对应的协程

# sync.Cond 应用场景
1. 应用于一发多收的场景，即一组协程需要等待某一个协程完成一些前置准备的情况

# sync.Cond 注意事项
1. 被叫方必须持有锁
2. 主叫方可以持有锁，但允许不持有
3. 尽可能的减少无效唤醒

# Mutex 与 RWMutex 作用
1. 并发场景下，通过锁机制，解决数据竞争的问题

# Mutex 与 RWMutex 应用场景
1. 协程安全
2. 数据竞争

# 注意事项
1. 尽量避免使用锁
2. 应合理使用锁机制，不要滥用

# sync.Map
1. 一个线程安全集合，内部通过原子访问和锁机制实现结合的线程安全

# sync.Map 应用场景
1. 适合读多写少的应用场景
2. 在 key 值已存在的情况下，可以无锁修改其 value，比普通 map + 锁性能更好





# sync, Pool注意事项
1. 用于缓存一些创建成本较高，使用比较频繁的对象
2. Pool的长度默认为机器CPU线程数
3. 存储在Pool中的对象随时都可能在不被通知的情况下被回收
4. 没有什么创建成本的对象下就加你使用对象池

# sync.Once 作用
1. 用来初始化单例资源

# sync.Once 使用场景
1. 单例场景
2. 仅加载一次的数据懒加载场景

# sync/atomic 作用
1. atomic 包提供底层的原子级内存操作，用于实现同步算法

# 应用场景
1. 通过内存实现通信

# 注意事项
1. atomic 属于底层原子操作，如无必要请使用通道或者 sync 包的其他函数或类型实现同步算法
2. 如果没有把握正确使用 atomic 那么请不要使用